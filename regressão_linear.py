# -*- coding: utf-8 -*-
"""Regressão Linear.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JHl4BEOXsxq0vKDZtsSyuZ0J9YF0an0V
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
# %matplotlib inline

import seaborn as sns

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

from yellowbrick.regressor import ResidualsPlot

import statsmodels.formula.api as sm

from google.colab import drive
drive.mount('/content/gdrive')

dados= pd.read_csv('go_track_tracks.csv')

dados.info()

dados.head(20)

sns.pairplot(dados)

dados = dados.drop(['id_android','id','linha'],axis=1)

sns.pairplot(dados) # Há uma relação importante nos dados abaixo para definir a melhor trajetória do GPS

sns.heatmap(dados.corr())

dados.columns

dados['car_or_bus'].unique()

"""**Análise dos Carros**

---


"""

carros = dados[dados['car_or_bus'] == 1][['speed', 'distance']]

x_carros= carros['distance']

y_carros= carros['speed']

x_treino, x_teste, y_treino, y_teste = train_test_split(x_carros,y_carros,test_size=0.3, random_state=101)

modelo=LinearRegression()

x_treino.shape

xtreino = x_treino.values

xtreino = xtreino.reshape(-1,1)

modelo.fit(xtreino,y_treino)

modelo.intercept_

modelo.coef_

xteste=x_teste.values
xteste=xteste.reshape(-1,1)

predicao=modelo.predict(xteste)

predicao

plt.figure(figsize=(14,10))
plt.scatter(y_teste, predicao)

y_teste

y_teste-predicao

sns.distplot((y_teste-predicao))

modelo.intercept_ + modelo.coef_ * 40

previsoes=modelo.predict(xtreino)

previsoes

modelo.score(xtreino,y_treino)

x_treino.head()

teste_previ = np.array([5])

teste_previ = teste_previ.reshape(1,-1)

teste_previ.shape

modelo.predict(teste_previ)

"""**Análise dos ônibus**

---



"""

onibus = dados[dados['car_or_bus'] == 2][['speed', 'distance']]

x_onibus= onibus['distance']

y_onibus= onibus['speed']

xn_treino, xn_teste, yn_treino, yn_teste = train_test_split(x_onibus,y_onibus,test_size=0.3, random_state=101)

modn=LinearRegression()

xn_treino.shape

xntreino = xn_treino.values

xntreino = xntreino.reshape(-1,1)

modn.fit(xntreino,yn_treino)

modn.intercept_

modn.coef_

predi=modn.predict(xnteste)

predi

plt.figure(figsize=(14,10))
plt.scatter(yn_teste, predi)

yn_teste

yn_teste-predi

sns.distplot((yn_teste-predi))

modn.intercept_ + modn.coef_ * 40

modn.score(xntreino,yn_treino)

prevn=modn.predict(xntreino)

prevn

xn_treino.head()

teste_previsao = np.array([5])

teste_previsao=teste_previsao.reshape(1,-1)

teste_previsao.shape

modelon.predict(teste_previsao)

modeloajustado=sm.ols(formula='speed~distance + time + rating + rating_bus + rating_weather + car_or_bus', data = dados)
modelotreinado = modeloajustado.fit()
modelotreinado.summary()

"""Conclusão

---



Após um treino de Regressão Linear simples, percebemos que para analisar os dados corretamente, precisávamos separar as duas classes de car_or_bus, que são ônibus e carro, ao separar utilizamos a relação velocidade e distância nos veículos, com o intuito de acompanhar essa relação em cada veículo. Infelizmente o treino não foi bem sucedido, ambos apontaram uma previsão muito diferente do esperado e não conseguimos ter uma boa análise
"""

dados['rating_weather'].value_counts()

dados['rating_bus'].value_counts()